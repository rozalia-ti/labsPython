# Лабораторная работа P3122 Тихонова Роза 501455
## Описание лабораторной работы
Цель лабораторной работы - выяснить различие скоростей работы разных подходов по вычислению факториала числа: рекурсивного и итеративного. Для наглядности результат работы скоростей выполнения функций выводится в виде графиков с помощтю библиотеки matplotlib.

## Описание файлов и работы функций: 
**main.py**
### Импорт библиотек: 
```
import timeit
import matplotlib.pyplot as plt
import random
from functools import lru_cache
```
timeit - засекает время выполнения функции создания факториала и выбирает наименьшее время выполнения  

matplotlib - библиотека для визуализации с помощью графиков
random - встроенный модуль python  

functools - библиотека для кеширования, которая сокращает время выполнения функции

### Описание работы функций 

1. Вычисление факториала рекурсивным методом
```
def fact_recursive(n: int) -> int:
    """Рекурсивный факториал"""
    if n == 0:
        return 1
    return n * fact_recursive(n - 1)
```
- Внутри себя использует рекурсию с выходом, если n равен нулю.

2. Итеративный подход в вычислении факториала
```
def fact_iterative(n: int) -> int:
    """Нерекурсивный факториал"""
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res
```
- Внутри себя использует цикл range, переменная res последовательно умножается на подряд идущие числа до n + 1 невключительно. 

3. Методы с использованием кеширования.  

Рекурсивный вариант:
``` 
@lru_cache(maxsize=None)
def fact_recursive_cached(n: int) -> int:
    """Рекурсивный факториал с кешированием"""
    if n == 0:
        return 1
    return n * fact_recursive_cached(n - 1)
```
Итеративный вариант:
```
@lru_cache(maxsize=None)
def fact_iterative_cached(n: int) -> int:
    """Итеративный факториал с кешированием"""
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res
```
- Используется декоратор @lru_cache из библиотеки functools, который сохраняет предыдущие результаты вычислений, что существенно сокращает время выполнения функций.  

4. Бенчмарк-функция. Возвращает среднее минимальное время выполнения.
```
def benchmark(func, data, number=1, repeat=5):
    """Возвращает среднее время выполнения func на наборе data"""
    total = 0
    for n in data:
        times = timeit.repeat(lambda: func(n), number=number, repeat=repeat)
        total += min(times)
    return total / len(data)
```
- func - тестируемая функция

- data - входные данные (заданное число)

- number=1 - количество выполнений за одно измерение

- repeat=5 - количество повторений измерений

5. main-функция - внешняя функция-обёртка.
```
def main():
    #Вычисление, замер времени и вывод графиков.
        
```
- Создаёт данные для вычислений
- Измеряет время выполнения
- Строит графики и выводит результаты


### Запуск
Программу можно запустить локально с помощью команды:
```
py main.py
```
На выводе вы увидите визуальное представление того, с какой скоростью выполнились функции (см. ниже)

### Визуальное сравнение графиков
После запуска ввыведутся два графика подобные этим:  

 ![Вывод графиков скорости выполнения функций](photo_2025-10-03_15-34-22.jpg)